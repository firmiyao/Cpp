<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [C++内联函数：](#c%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0)
- [引用变量：](#%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F)
  - [创建引用变量：](#%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F)
  - [将引用用作函数参数：🔴](#%E5%B0%86%E5%BC%95%E7%94%A8%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# C++内联函数：

+ **内联函数是C++为了提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将他们组合到程序中**

+ **对于常规函数的调用，根据代码的长度需要进行一系列的调用，而内联函数无需跳到另一个位置执行代码，再跳回来，所以速度更快，不过代价是要付出更多的内存**
+ **记住：如果执行函数代码的时间的处理函数调用机制的时间长，则节省的时间将只占整个过程的很小部分。如果代码执行的时间很短，则内联调用就可以节省非内联调用使用的大部分时间**
+ 内联函数不能递归

关键字：***inline***

措施：

+ 在函数声明前加上inline
+ 在函数定义前加上inline

展示：

```c++
#include<iostream>
using namespace std;
inline int fun(int n);    //函数声明前加inline
int main()
{
    cout << fun(3);
    return 0;
} 
inline int fun(int n)    //函数定义前加inline
{
    return n * n;
}
```

结果为9；**如果内联函数过大或者调用了自己，那么编译器不会满足这种要求。**

***

# 引用变量：

C++新增了一种复合类型——引用变量。**引用是已定义的变量的别名**

**引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。（与指针类似）**

## 创建引用变量：

关键字：***&***，这里不指取地址符。

上才艺：

```c++
#include<iostream>
using namespace std;
int main()
{
    int n = 8;
    int& m = n;   //n的别名为m；
    cout << "m = " << m << endl;
    cout << "&n = " << &n << endl;
    cout << "&m = " << &m << endl;    //这里的&是取地址符
    n++;
    cout << "n = " << n << endl;
    cout << "m = " << m << endl;
    m++;
    cout << "n = " << n << endl;
    cout << "m = " << m << endl;
    return 0;
} 
```

![image-20221010231840490](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202210102318519.png)

结果如上，可知：

+ m和n的地址和值都相等
+ 两个值只要一个变，另一个也变化

指针和引用有一定的相似性，但也有差别，比如：**必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。引用更接近于 const 指针，必须在创建时初始化，一旦与某个变量关联起来，就将一直效忠于他。

```c++
#include<iostream>
using namespace std;
int main()
{
    int n = 8;
    int& m;   
    m = n;
    return 0;
} 
```

这是错误的做法，不能先声明再赋值。

```c++
int & m = n;
等效于：
int * const m = & n ;
```

理解以下程序：

```c++
#include<iostream>
using namespace std;
int main()
{
    int n = 8;
    int& m = n;
    cout << "n = " << n << endl;
    cout << "m = " << m << ", &m = " << &m << endl;
    int c = 3;
    m = c;
    cout << "c = " << c << endl;
    cout << "m = " << m << ", &m = " << &m << endl;
    c++;
    cout << "c = " << c << endl;
    cout << "m = " << m << ", &m = " << &m << endl;
    return 0;
} 
```

![image-20221010233528103](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202210102335128.png)

表面上看m的变了，不过 m 依然效忠于 n 的地址。

***

## 将引用用作函数参数：🔴




<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [标准库类型string：](#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring)
  - [定义和初始化string对象：](#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string%E5%AF%B9%E8%B1%A1)
  - [string对象上的操作：](#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C)
    - [读写string：](#%E8%AF%BB%E5%86%99string)
    - [empty和size操作：](#empty%E5%92%8Csize%E6%93%8D%E4%BD%9C)
      - [size_type类型：](#size_type%E7%B1%BB%E5%9E%8B)
    - [比较string对象：](#%E6%AF%94%E8%BE%83string%E5%AF%B9%E8%B1%A1)
    - [字面值和string对象相加：](#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%92%8Cstring%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%8A%A0)
  - [处理string对象中的字符：](#%E5%A4%84%E7%90%86string%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6)
    - [处理每个字符？基于范围的for语句：](#%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5)
    - [改变字符：](#%E6%94%B9%E5%8F%98%E5%AD%97%E7%AC%A6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 标准库类型string：

**标准库类型_string_表示可变长的字符序列**，其定义位于头文件**_string_**中。

## 定义和初始化string对象：

一个类可以有多种初始化方法，以下是几个例子：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s_1;  //定义了一个空串
	string s_2 = "hello";
	string s_3 = s_2;   //复制
	string s_4(6,'c');   //s_4的内容为"cccccc"
	cout << s_1 << " " << s_2 << " " << s_3 << " " << s_4 << endl;
	return 0;
}
```

结果如下：

![image-20221230211725527](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202212302117618.png)

此外还可以进行以下定义：

```c++
string s_1="hello";
string s_2(s_1);     //等效于string s_2=s_1
string s_3("world")   //等效于string s_3 ="world"
```

初始化主要分为两种：

+ **拷贝初始化：使用等号（=）初始化一个变量，实际上执行的是拷贝初始化**
+ **直接初始化：与拷贝初始化相反，如果不使用等号，则执行的是直接初始化**

一般情况下，当初始值只有一个时，两者都可以使用，但是当要用多个值进行初始化时，要用**拷贝初始化**也不是不可以，比如：

```c++
string s_1(4,'c');   //这里使用的时直接初始化
//若要使用拷贝初始化
string s_2=string s_3(4,'c');
```

两者的效果是一样的，不过在拷贝初始化中，创建了一个临时变量，再将其拷贝给了s_2，浪费了内存，更适合使用直接初始化。

## string对象上的操作：

|    cout<<s     |       将s输出        |
| :------------: | :------------------: |
|     cin>>s     |       将s输入        |
| getline(cin,s) |   读取一行赋值给s    |
|   s.empty( )   | 判断s是不是一个空串  |
|   s.size( )    |   返回s的字符个数    |
|      s[n]      |        下标法        |
|     s1+s2      |    将s2接在s1后面    |
|     s1=s2      |      s1复制为s2      |
|     s1==s2     |  判断s1和s2是否相等  |
|     s1!=s2     | 判断s1和s2是否不相等 |
|   <,>,<=,>=    |   按字典的顺序比较   |

***



### 读写string：

例：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s_1;
	string s_2;
	cin >> s_1;   //忽略输入流前的空白读取内容，遇到空白或者换行符停止
	getline(cin, s_2);  //读取一行的值
	cout << s_1<<endl<<s_2;
	return 0;
}
```

![image-20221230213915293](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202212302139315.png)

注意：**getline读取一行，直到读到换行符，且将其读取后丢弃，所以输入流中不剩余换行符**

***



### empty和size操作：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s;
	cout << s.empty() << endl;   //判断是否为空串
	string s_2 = "h ello";
	cout << s_2.empty() << endl;
	cout << s_2.size() << endl;   //输出其长度
	return 0;
}
//答案为1 0 6
```

#### size_type类型：

可知**size**返回的是字符串的长度，不过，请看下列代码：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s("hello");
	signed int n = -1;
	cout << (s.size() > n) << endl;
	return 0;
}
```

其结果为0，说明s的长度小于负一，这显然不可能，因为s的长度为5，**问题在于size的返回类型为string::size_type，是一个无符号整型数，当一个 singed 的数和 unsigned 比较时，就需要从 signed 转换为 unsigned 的数，若原本为一个负数，则转换后可能是一个很大的 unsigned 数**

因此，**以后若要用某个数去和size（）比较时，最好也用size_type类型的值去比较**，可以如下定义：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s("hello");
	string::size_type n=s.size();   //n的类型为size_type
	auto l = s.size();  //l的类型为size_type
	decltype(s.size()) m = s.size();   //m的类型为size_type
	return 0;
}
```

***



### 比较string对象：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s_1("hello");
	string s_2("hello hh");
	cout << (s_1 < s_2) << endl;  //输出1
	return 0;
}
```

按照字典的内容比较，注意上面代码中的s_1和s_2，虽然s_1和s_2的前面都相同，不过后面s_2更长，所以后者大于前者。

***



### 字面值和string对象相加：

**标准库允许把字符字面值和字符串字面值转化成string对象，记住是转换成string对象**

举例：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
using namespace std;
int main(void)
{
	string s_1("hello");
	string s_2("C++");
	cout << s_1 + " " + s_2 + '\n';  
	//该处既有添加字符串常量，也有添加字符常量
	return 0;
}
//输出为：hello C++
//(换行符)
```

约定：**当把string对象和字符串字面值和字符字面值相加混用时，必须保证每个加法运算符（+）的两侧的运算对象至少有一个是string对象。**

如下就是错误操作:

```c++
string s="hello" + 'v';  //这是错误的，根本没有string对象
string s_3("wtf");
string s_1="hello"+' '+ s_3;  //这也是错误的，不符合规则，字符串常量和字符常量不能相加
```

牢记：**字符串字面值和string是不同的类型**

***

## 处理string对象中的字符：

### 处理每个字符？基于范围的for语句：

```c++
for(临时变量t（用于访问string）: string 对象)
    statement
```

举一个例子，统计string中的标点符号：(这里用到头文件cctype)

```c++
#include<iostream>
#include<string>  //记得头文件包含string
#include<cctype>
using namespace std;
int main(void)
{
	string s("h,h.hl.");
	int tot = 0;
	for (char t : s)  //也可以写为（auto t:s）或者（s[0]) t : s），都为char类型
		if (ispunct(t))
			tot++;
	cout << tot << endl;
	return 0;
}
//输出为3
```

### 改变字符：

使用**索引**：将字符串大写化：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
#include<cctype>
using namespace std;
int main(void)
{
	string s("hello world");
	decltype(s.size()) begin = 0;
	auto end = s.size();
	while (begin != end)
	{
		s[begin]=toupper(s[begin++]);
	}
	cout << s << endl;
	return 0;
}
//结果为：
```

另外，也可以用for循环操作，**不过要注意方法，此时要去访问字符串的地址，而不是它的拷贝，要使用引用或者指针。**

```c++
#include<iostream>
#include<string>  //记得头文件包含string
#include<cctype>
using namespace std;
int main(void)
{
	string s("hello world");
	for (auto t : s)
		t = toupper(t);
	cout << s << endl;
	return 0;
}
//输出不变，还是小写
```

可以进行以下修改：

```c++
#include<iostream>
#include<string>  //记得头文件包含string
#include<cctype>
using namespace std;
int main(void)
{
	string s("hello world");
	for (auto& t : s)
		t = toupper(t);
	cout << s << endl;
	return 0;
}
```

此时是成功的。

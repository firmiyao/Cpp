<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [字面值常量](#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F)
  - [整型字面值：](#%E6%95%B4%E5%9E%8B%E5%AD%97%E9%9D%A2%E5%80%BC)
  - [字符和字符串字面值](#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC)
  - [转义序列](#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)
- [变量](#%E5%8F%98%E9%87%8F)
  - [变量声明和定义的关系](#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%B3%E7%B3%BB)
    - [extern](#extern)
  - [标识符](#%E6%A0%87%E8%AF%86%E7%AC%A6)
  - [作用域](#%E4%BD%9C%E7%94%A8%E5%9F%9F)
- [复合类型](#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B)
  - [引用](#%E5%BC%95%E7%94%A8)
  - [指针](#%E6%8C%87%E9%92%88)
    - [地址（&）](#%E5%9C%B0%E5%9D%80)
    - [取值（*）](#%E5%8F%96%E5%80%BC)
    - [空指针赋值：](#%E7%A9%BA%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC)
    - [其它指针操作](#%E5%85%B6%E5%AE%83%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C)
- [理解复合类型的声明](#%E7%90%86%E8%A7%A3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E)
  - [指向指针的指针](#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88)
  - [指向指针的引用](#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8)
- [const限定符](#const%E9%99%90%E5%AE%9A%E7%AC%A6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 字面值常量

一个形如34的值被称为**字面值常量**，这样的值一望而知。每个字面值常量都对应一种数据类型。



## 整型字面值：

整型字面值分为**十进制，八进制，十六进制**，八进制以以数字`0`开头，十六进制以`0x`开头 。

```c++
#include<iostream>

int main() {
    int a = 012;//八进制
    int b = 0x12; //十六进制
    std::cout<<a<<" "<<b;
}
//10 18
```



## 字符和字符串字面值

**由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值**

字符串字面值的类型实际上是由常量字符构成的数组，并在结尾添加一个空字符`'\0'`，因此，字符串字面值的实际长度要比它的内容多1。



## 转义序列

有两类字符程序员不能直接使用，一类是**不可打印**的字符，比如换行符，制表符等。另一类是有特殊含义的字符，比如引号，反斜线等。这些时候，需要用到`转义序列`。

常见转移字符:

+ `\n`:回车符

+ `\t`:横向制表符

+ `\v`:纵向制表符

+ `\\`:反斜线

+ `\r`:回车符

+ `\"`:双引号

+ `\'`:单引号

+ `\?`:问好

+ `\b`:退格符

+ `\a`:响铃

+ `\0XXX`:一到三个八进制数字，其中数字表示的是字符对应的数值。

+ `\xXXX`:一个或两个十六进制数字。

   ```c++
   #include<iostream>
   
   int main() {
       std::cout<<"\1413";
   }
   //输出为a3，注意八进制仅仅前三位有效，十六进制可以用2位。
   ```

   

# 变量

**变量提供一个具名的，可供程序操作的存储空间。**



## 变量声明和定义的关系

C++语言支持`分离式编译`，即允许将程序分割成若干个文件，每个文件可以被独立编译。

**`声明`使得名字为程序所知，一个文件如果想要使用别处定义的名字则必须包含对那个名字的声明。而`定义`负责创建与名字关联的实体。**

**变量声明规定了变量的类型和名字，定义申请了存储空间，也可能会为变量赋一个初始值**



### extern

**如果想要声明一个变量而非定义它，就在变量名前添加关键字`extern`，而不要显式地初始化变量**

```c++
int j;  //声明并定义了j
extern int i;  //声明了i，但是没有定义
extern int k = 1;  //定义了k，抵消了extern的作用
```

**变量能且只能被定义一次，但是可以被多次声明。注意定义不等于赋值，赋值是把当前值擦除，而以一个新值来替代。**



如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对它进行声明，且不能重复定义。



## 标识符

**C++的标识符由字母，数字和下划线组成，其中必须以字母或者下划线开头**。



## 作用域

举例：

```c++
#include<iostream>
int a = 1;//全局作用域
using std::cout,std::endl;
int main() {
    int b = 2; //局部作用域
    cout<<b<<endl;

    int a =3;
    cout<<a<<endl;

    cout<<::a<<endl;
}
//2 3 1
```

解释：第一个a具有全局作用域，第二个a和b具有局部作用域，通过作用域操作符可以调用全局变量a，注意全局作用域本身没有名字。



# 复合类型

复合类型是指基于其他类型定义的类型。

**一条声明语句由一个`基本数据类型`和紧跟其后的声明符列表组成，声明符就是`变量名`**



## 引用

`引用`为对象起了另外一个名字。

注意，**引用指向一个对象，引用会和那个对象绑定在一起，而不是创建一个新的对象。引用始终只能绑定在一个对象上，因此引用在被声明的时候必须被初始化。**

```c++
#include<iostream>
#include<string>
using std::cout,std::endl;
int main() {
    int i =1;
    int &a = i;
    cout<<a<<endl;
    std::string s = "hello";
    std::string &b =s;
    cout<<b<<endl;
}
//1
//hello
```

这就是引用，**引用本身不是一个对象，因此没有指向引用的引用**，除了两种情况，**所有引用的类型都要和与之，绑定的对象严格匹配**。



## 指针

**`指针`是“指向”另外一种类型的复合类型。**它与引用类似，但是有所不同：

+ **指针本身就是一个对象，允许对其赋值和拷贝，指针可以先后指向不同的对象**
+ **指针无须在定义的时候赋初值**



### 地址（&）

指针存放某个对象的地址，要想获取某个对象的地址，需要使用**取地址符**（`&`）。

```c++
#include<iostream>

using std::cout,std::endl;
int main() {
    int a = 1;
    int *p = &a;
    cout<<p<<endl;
    cout<<&a<<endl;
}
```

![image-20231219214904713](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312192149743.png)

两者输出一致，都指向对象a的地址。



### 取值（*）

如果指针指向了一个对象，则允许使用**解引用符**`*`来访问该对象，其实返回了一个该对象的引用。

```c++
#include<iostream>

using std::cout,std::endl;
int main() {
    int a = 1;
    int *p = &a;
    cout<<*p<<endl;
    *p=2;
    cout<<a<<endl;
}
//1
//2
```



### 空指针赋值：

下列方法可以生成空指针：

+ ```c++
   int *p1 = nullptr;
   ```

+ ```c++
   int *p2 = 0;
   ```

   但是不能把一个值为0的int变量赋值给p2。

+ ```c++
   int *p3 = NULL;
   ```

   NULL是一个**预处理变量**，它的值就是0。

​                                                                                                                                                                                                                                                                       



### 其它指针操作

+ **指针可以是一个判断条件，空指针代表false，其余指针代表true**
+ **指针可以进行“==”和“!=”操作，这是比较指针指向的地址，相同为true，不同为false。**



# 理解复合类型的声明

经常有一种观念会误以为，在定义中，类型修饰符（*或&）作用于本次定义的全部变量。一个重要的原因是我们经常这样写：

```c++
int* p,a;
```

这样显得p和a都是指针，不过只用p才是指针，a是整型对象。



## 指向指针的指针

指针不同于引用，指针是对象，可以有指向指针的指针：

```c++
#include<iostream>
using std::cout,std::endl;

int main() {
    int a=1;
    int *p = &a;  
    int **p2 =&p;
    cout<<"p = "<<p<<endl;   //a的地址
    cout<<"*p = "<<*p<<endl;  
    cout<<"&p = "<<&p<<endl;  //指针p的地址
    cout<<"p2 = "<<p2<<endl;  //指针p的地址
    cout<<"**p2 = "<<**p2<<endl;
}
```

![image-20231219221216669](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312192212700.png)





## 指向指针的引用

指针是一个对象，所以可以有指向指针的引用

```c++
#include<iostream>
using std::cout,std::endl;

int main() {
    int a = 1;
    int *p = &a;
    int *&r = p;   //指向指针的引用
    cout<<*r<<endl;
    *r=2;
    cout<<a<<endl;
}
//1
//2
```





# const限定符

有时候我们希望有这样一种变量，它的值不能被改变，为了满足这一要求，我们可以使用关键字`const`对变量的类型加以限定。

```c++
const int a = 1;
a = 2;  //错误，不能对a赋值。
```

因为const对象一旦创建后值就不能够改变，所以const对象必须初始化。
























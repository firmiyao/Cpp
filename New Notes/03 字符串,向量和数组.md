<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [命名空间的using声明](#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E)
  - [头文件和using声明](#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8Cusing%E5%A3%B0%E6%98%8E)
- [标准库类型string](#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring)
  - [定义和初始化string](#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96string)
  - [操作string](#%E6%93%8D%E4%BD%9Cstring)
    - [读写string](#%E8%AF%BB%E5%86%99string)
      - [使用getline读取一整行](#%E4%BD%BF%E7%94%A8getline%E8%AF%BB%E5%8F%96%E4%B8%80%E6%95%B4%E8%A1%8C)
    - [empty和size操作](#empty%E5%92%8Csize%E6%93%8D%E4%BD%9C)
      - [string::size_type](#stringsize_type)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 命名空间的using声明

到目前为止，我们用到的库函数基本上都是属于命名空间`std`的，而程序也是显式地将这一点表示了出来，如`std::cin`，这里使用了作用域操作符`::`，这样显得比较繁琐，所以可以使用`using声明`，语法如下：

```c++
using namespace :: name ;
using std::cin;
```

## 头文件和using声明

**头文件不应该包含using声明，因为头文件的内容会拷贝到所有引用它的文件中去，对于某个程序，由于不经意的包含了一些名字，反而可能产生始料未及的名字冲突。**



# 标准库类型string

**标准库类型`string`表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。**

```c++
#include<string>
using std::string;
```



## 定义和初始化string

```c++
string s1;   //是一个空串
string s2(s1);   //s2是s1的副本
string s3 = s2;  //s3是s2的副本
string s4("value");  //s4是字面值"value"的副本，但是不包括'\0'
string s5(n,'c')  //s5是n个字符'c'的副本
```



## 操作string

### 读写string

string的读写也使用cin和cout来操作，其中，**在执行读操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读取，直到遇到一下处空白为止**

```c++
#include<iostream>
#include<string>
using std::string,std::cin,std::cout,std::endl;

int main() {
    string a,b;
    cin>>a>>b;
    cout<<a<<endl;
    cout<<b<<endl;
    return 0;
}
```

![image-20231219231547754](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312192315778.png)

#### 使用getline读取一整行

有时候我们希望能在最终得到的字符串中保留输入时的空白符，这个时候应该用`getline`函数，getline运算符直到遇到**换行符**为止（注意换行符被读取，但是不保存到string对象中）

举例：多次读取一行

```c++
#include<iostream>
#include<string>
using std::string,std::cin,std::cout,std::endl;

int main() {
    string t;
    while(getline(cin,t)){
        cout<<t<<'\n';
    }
    return 0;
}
```



### empty和size操作

**empty()函数根据string对象是否为空返回一个对应的布尔值**

**size()函数返回string对象的长度**



#### string::size_type

对于size()函数来说，它的返回值好像是一个int对象，不过size的返回值是一个无符号数，就是`string::size_type`。

```c++
#include<iostream>
#include<string>
using std::string,std::cin,std::cout,std::endl;

int main() {
    string s = "hello";
    cout<<s.size()<<endl;
    int n=-1;
    cout<<(s.size()<n);   // 5 <- 1 返回0
    return 0;
}
```

![image-20231219233132914](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312192331938.png)

很显然，5是大于-1的，但是此时的int为负数，和无符号数比较发生了转换，变成了一个很大的数。






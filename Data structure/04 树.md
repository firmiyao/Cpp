<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [树的定义](#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89)
- [树的基本术语:fire:](#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%ADfire)
  - [结点的度和树的度：](#%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E5%92%8C%E6%A0%91%E7%9A%84%E5%BA%A6)
  - [分支结点和叶子结点：](#%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%E5%92%8C%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9)
  - [路径和路径长度：](#%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6)
  - [孩子结点，双亲结点和兄弟结点：](#%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9%E5%92%8C%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9)
  - [结点层次和树的高度：](#%E7%BB%93%E7%82%B9%E5%B1%82%E6%AC%A1%E5%92%8C%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6)
  - [森林：](#%E6%A3%AE%E6%9E%97)
- [树的存储结构：:fire:](#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84fire)
  - [双亲存储结构：](#%E5%8F%8C%E4%BA%B2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
  - [孩子链存结构：](#%E5%AD%A9%E5%AD%90%E9%93%BE%E5%AD%98%E7%BB%93%E6%9E%84)
  - [孩子兄弟链存结构](#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E9%93%BE%E5%AD%98%E7%BB%93%E6%9E%84)
    - [实例：](#%E5%AE%9E%E4%BE%8B)
      - [双亲存储：](#%E5%8F%8C%E4%BA%B2%E5%AD%98%E5%82%A8)
      - [孩子存储：](#%E5%AD%A9%E5%AD%90%E5%AD%98%E5%82%A8)
      - [孩子兄弟：](#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 树的定义

**树是由n（n>=0）个结点组成的有限集合。**

**如果n=0，它是一棵空树，这是树的特例；如果n>0，这n个结点中有且仅有一个结点作为树的根结点，简称为根（root）。树的定义是递归的，一棵树由若干棵互不相交的子树构成，而子树又由更小的若干棵子树构成。**

# 树的基本术语:fire:

![bb573a8f7fc2f87c130bc77356c3524](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092256220.jpg)

## 结点的度和树的度：

**树中某个结点的子树的个数称为该结点的度。树中所有结点的度中的最大值称为树的度。**如图是一棵三次树。

**牢记：树的结点数等于所有结点的度数之和加一。（树的所有结点的度数之和等于结点数减一。）**

## 分支结点和叶子结点：

**树中度不为0的结点称为非终端结点，又叫分支结点。度为0的结点称为叶子结点。在分支结点中，每个结点的分支数就是该结点的度。**

## 路径和路径长度：

**路径长度是该路径所经的结点数目减1。（即路径上分支个数）**

## 孩子结点，双亲结点和兄弟结点：

**每一棵树中，每个结点的后继结点被称为该结点的孩子结点，而该结点就是孩子结点的双亲结点。具有同一双亲结点的孩子结点互为兄弟结点。后继的出现了子孙结点和祖先结点。**

## 结点层次和树的高度：

**树的每一个结点都处在一定的层次上。根节点为第一层。树中结点的最大层次称为树的高度或者树的深度。**

## 森林：

**n个互不相交的树的集合称为森林。把含有多棵子树的树的根节点删除就成了森林。反之，也可以给树添加根结点变成森林。**

***

# 树的存储结构：:fire:

## 双亲存储结构：

**双亲存储结构是一种顺序存储结构，用一组连续空间存储树的所有结点，同时在每个结点中附设一个伪指针指示其双亲结点的位置（只需要一个伪指针，因为双亲结点是唯一的。），并将根结点的伪指针设置为-1，毕竟它没有。**

结点声明如下：

```c++
//Parents_Tree.hpp
#ifndef TREE_PARENTS_TREE_HPP
#define TREE_PARENTS_TREE_HPP
struct data{
    int num;
    data*parents= nullptr;
};
#endif
```

**在这种存储结构中，求某个结点的双亲结点十分容易，但是求某个结点的孩子结点时需要遍历整个存储结构。**

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092257261.jpg" alt="caf2d254cc5b240c905bfcb6bd86535" style="zoom:50%;" />

***

## 孩子链存结构：

**孩子链存结构中，每个结点不仅包含结点值，还包括指向所有孩子结点的指针。由于树中的每个结点的度不同（孩子个数），为了方便，设孩子指针个数为树的度。**

结点声明如下：

```c++
#ifndef TREE_CHILDREN__TREE_HPP
#define TREE_CHILDREN__TREE_HPP
struct data{
    int num;
    data *ptrs[3]={nullptr};
};
#endif //TREE_CHILDREN__TREE_HPP
```

**孩子链存结构与双亲存储结构的优缺点相反，缺点还有：当树的度较大时存在较多的空指针域。**

![ef0c2fc222e6ecb8b69ad22e7258e47](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092258871.jpg)

***

## 孩子兄弟链存结构

**孩子兄弟链存结构是为每个结点设计3个域：数据元素域，一个指向该结点的左边的第一个孩子结点（长子）的指针域，一个指向该结点的下一个兄弟结点的指针域。**

结点声明如下：

```c++
#ifndef TREE_PS_TREE_HPP
#define TREE_PS_TREE_HPP
struct data{
    int num;
    data*child= nullptr;
    data*brother= nullptr;
};
#endif //TREE_PS_TREE_HPP
```

**孩子兄弟链存储结构固定有两个指针域，并且是有序的，一个指向长子结点，一个指向下一个兄弟，所以孩子兄弟链存储结构实际上是把该树转换为二叉树的存储结构。**

**孩子兄弟链存结构的最大优点是可以与二叉树方便的转换，缺点是从某节点查找双亲结点比较麻烦。**

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092259891.jpg" alt="b5dab11483101fba1919b1813dd799c" style="zoom:33%;" />

***

### 实例：

构建如图的树：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092333530.png" alt="image-20230309233322447" style="zoom:25%;" />

#### 双亲存储：

```c++
#include <iostream>
#include"Parents_Tree.hpp"
int main() {
    data tree[7];
    tree[0].parents= nullptr;
    tree[1].parents=&tree[0];
    tree[2].parents=&tree[0];
    tree[3].parents=&tree[0];
    tree[4].parents=&tree[2];
    tree[5].parents=&tree[2];
    tree[6].parents=&tree[2];
    for(int i=0;i<7;i++)
    {
        tree[i].num=i;
    }
    for(int i=0;i<7;i++)
    {
        if(tree[i].parents!= nullptr)
        std::cout<<"parent:"<<(*(tree[i].parents)).num<<" ";
        else
            std::cout<< nullptr<<" ";
        std::cout<<"myself:"<<tree[i].num<<std::endl;
    }
    return 0;
}
```

结果如下:

![image-20230309233654651](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303092336695.png)

#### 孩子存储：

```c++
#include <iostream>
#include"Children._Tree.hpp"
int main() {
    data tree[7];
    tree[0].ptrs[0]=&tree[1];
    tree[0].ptrs[1]=&tree[2];
    tree[0].ptrs[2]=&tree[3];
    tree[2].ptrs[0]=&tree[4];
    tree[2].ptrs[1]=&tree[5];
    tree[2].ptrs[2]=&tree[6];
    int num=0;
    for(data &t :tree)
    {
        t.num=num++;
    }
    for(data &t:tree)
    {
        std::cout<<"myself:"<<t.num<<" and ";
        std::cout<<"my children:";
        data**p=t.ptrs;
        int time=0;
        while(*p!= nullptr&&time!=3)
        {
            std::cout << (*(*p)).num << " ";
            p++;
            time++;

        }
        std::cout<<std::endl;
    }
    return 0;
}
```

结果如下：

![image-20230310000141287](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303100001335.png)

#### 孩子兄弟：

```c++
#include <iostream>
#include"PS_Tree.hpp"
int main() {
    data tree[7];
    tree[0].child=&tree[1];
    tree[1].brother=&tree[2];
    tree[2].child=&tree[4];
    tree[2].brother=&tree[3];
    tree[4].brother=&tree[5];
    tree[5].brother=&tree[6];
    int num=0;
    for(data &t :tree)
    {
        t.num=num++;
    }
    for(data &t:tree)
    {
        std::cout<<"myself:"<<t.num<<" and ";
        std::cout<<"my first child:";
        if(t.child== nullptr)
            std::cout<<"No ";
        else
            std::cout<<(*(t.child)).num<<" ";
        std::cout<<"my brother:";
        if(t.brother== nullptr)
            std::cout<<"No";
        else
            std::cout<<(*(t.brother)).num;
        std::cout<<std::endl;
    }
    return 0;
}
```

结果如下：

![image-20230310001252098](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202303100012147.png)

搭建完成。

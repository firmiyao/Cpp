<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [数据：](#%E6%95%B0%E6%8D%AE)
  - [数据元素——描述一个个体](#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BD%93)
  - [数据对象](#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1)
- [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
- [数据结构的三要素](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0)
  - [逻辑结构：](#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84)
  - [数据的运算：](#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97)
  - [物理结构（存储结构）](#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
- [数据类型和抽象数据类型](#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
- [算法：](#%E7%AE%97%E6%B3%95)
  - [算法的特性：](#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7)
  - [好算法的特质：](#%E5%A5%BD%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E8%B4%A8)
    - [冒泡排序：](#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
      - [实现：](#%E5%AE%9E%E7%8E%B0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 数据：

**数据是信息的载体，是描述客观事物属性的数，字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合，数据是计算机程序加工的原料。**

***



## 数据元素——描述一个个体

一个结构体对象

**一个个属性就是一个个数据项**

**数据元素是数据的基本单位，通常作为一个整体进行考虑和处理**

**一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。**



## 数据对象

**数据对象是具有相同性质的数据元素的集合，是数据的一个子集**，如结构体数组。



# 数据结构

**数据结构是相互之间存在一种或多种特定关系的数据元素的集合。**强调数据对象里数据元素之间的关系。

**同一个数据对象里的数据元素，可以组成不同的数据结构**



# 数据结构的三要素

## 逻辑结构：

数据元素之间的逻辑关系：

+ 集合
+ 线性结构：数据元素之间是**一对一**的关系，除了第一个元素，所有元素都有唯一的前驱，除了最后一个元素，所有元素都有唯一后继
+ 树形结构：数据元素之间是**一对多**的关系
+ 图结构：数据元素之间是**多对多**的关系



## 数据的运算：

**针对于某种逻辑结构，结合实际需求，定义基本运算**

**运算的定义是针对逻辑结构**的，指出运算的功能；**运算的实现是针对存储结构**的，指出运算的具体操作步骤。



## 物理结构（存储结构）

**逻辑结构和数据的运算定义了一种数据结构，物理结构完成了具体的实现**。

常见：

+ 顺序存储：**把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中**，元素之间的关系由存储单元的邻接关系来体现。
+ 链式存储：**逻辑上相邻的元素在物理位置上不相邻**，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
+ 索引存储：在存储元素信息的同时，还建立附加的**索引表**。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。
+ 散列存储：根据元素的关键字直接计算出该元素的存储地址，又称为**哈希存储**。



# 数据类型和抽象数据类型

**数据类型是一个值的集合和定义在此集合上的一组操作的总称**

1. 原子类型。其值不能再分的数据类型，比如布尔类型，它的值的集合就是{true，false}，可以进行与，非，或操作
2. 结构类型。其值可以再分解为若干分量的数据类型。比如定义一个新类，它有多个属性和若干方法。

**抽象数据类型（ADT）：是抽象数据组织及与之相关的操作，即定义一种新的数据结构**



# 算法：

**算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。**（求解问题的步骤）

**程序 = 数据结构 + 算法**

## 算法的特性：

+ 有穷性。注：**算法必须是有穷的，而程序可以是无穷的。**如微信是程序而不是算法。
+ 确定性，算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
+ 可行性，都可以通过计算机语言实现
+ 输入：有零个或者多个输入
+ 输出：有一个或者多个输出



## 好算法的特质：

+ 正确性
+ 可读性
+ 健壮性：输入非法数据，算法可以相应地做出一些处理，不会产生莫名奇妙的输出结果。
+ **高效率与低存储量需求**



**四分之一以上的时间CPU都用于执行同一类型的计算：按照某种约定的次序，将给定的一组元素顺序排列，比如将n个整数按通常的大小次序排列成一个非降序列。这类操作统称排序**

### 冒泡排序：

**排序过程中，所有元素朝着各自最终位置亦步亦趋的移动过程，犹如气泡在水中的上下沉浮，冒泡排序因此得名。**

#### 实现：

```c++
void bubblesort(int a[], int n)
{
	bool sorted = false;
	while (!sorted)//借助布尔标志位sorted，可以及时退出，不必等到执行了n-1次扫描在退出
	{
		sorted = true;     //假定已经排序完毕
		for (int i = 1; i < n; i++)
		{
			if (a[i - 1] > a[i])
			{
				int t = a[i - 1];
				a[i - 1] = a[i];
				a[i] = t;
				sorted = false;    //因为整体排序不能保证，需要清楚排序标志
			}
		}
		n--;
	}
}
```

***

对冒泡排序有：**经过k趟扫描交换之后，最大的前k个元素必然就位；经过k趟扫描交换后，待求解问题的有效规模将缩减到 n-k 。**



# 时间复杂度：

## 事后统计的弊端

+ 和机器性能有关，如：笔记本VS单片机
+ 和编程语言有关，越高级的语言执行效率越低
+ 有些东西无法使用事后统计，如导弹控制算法



算法**时间复杂度T(n)**与**问题规模n**的关系



 例：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011424802.png" alt="image-20230701142403746" style="zoom: 33%;" />

 

## 常见数量级：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011451938.png" alt="image-20230701145137902" style="zoom: 67%;" />

口诀：“常对幂指阶”

牢记：

+ **顺序执行的代码只会影响常数项，可以忽略**

+ **只需要挑选循环中的一个基本操作分析它的执行次数与n的关系即可**

+ **如果有多层嵌套循环，只需要关心最深层循环循环了几次**

   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011512334.png" alt="image-20230701151229263" style="zoom: 33%;" />

### 指数递增型：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011515227.png" alt="image-20230701151511184" style="zoom:50%;" />

### 搜索数字型：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011518291.png" alt="image-20230701151838240" style="zoom: 33%;" />

 

# 空间复杂度：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011526916.png" alt="image-20230701152659866" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011530579.png" alt="image-20230701153044537" style="zoom: 33%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011531915.png" alt="image-20230701153113876" style="zoom:33%;" />

## 递归调用带来的开销

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011536509.png" alt="image-20230701153651459" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202307011538580.png" alt="image-20230701153851538" style="zoom:33%;" />

 

